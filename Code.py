# -*- coding: utf-8 -*-
"""APPLIED OPTIMIZATION

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aD3Tjbw11V87LtHz1OmIo1P5uWNtmwod
"""

pip install yfinance

pip install cplex

"""# Import libraries"""

import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import json
import matplotlib.pyplot as plt
import cplex

"""# Getting the data from yahoo finance"""

stock_symbols = ['VIC.VN', 'HPG.VN', 'FPT.VN', 'VCB.VN', 'SSI.VN']
stocks = {}

for symbol in stock_symbols:
    stock = {}
    df = yf.download(symbol, start="2023-01-01")
    df["DailyReturn"] = df["Close"].pct_change()
    avg_return = df["DailyReturn"].sum() / len(df)
    df["DailyRisk"] = df["DailyReturn"].apply(lambda x: x-avg_return)
    df.drop(index=df.index[0],axis=0, inplace=True)

    stock["return"] = df["DailyReturn"].tolist()
    stock["risk"] = df["DailyRisk"].tolist()
    stock["avg_return"] = avg_return
    stock["last_price"] = df["Close"].iloc[-1]
    stocks[symbol] = stock

# List of stock symbols
stock_symbols = ['VIC.VN', 'HPG.VN', 'FPT.VN', 'VCB.VN', 'SSI.VN']
stocks = {}

for symbol in stock_symbols:
    stock = {}
    df = yf.download(symbol, start="2023-01-01", end="2024-11-08")  # Set the end date

    # Calculate daily returns
    df["DailyReturn"] = df["Close"].pct_change()

    # Calculate daily risk
    avg_return = df["DailyReturn"].sum() / len(df)
    df["DailyRisk"] = df["DailyReturn"].apply(lambda x: x - avg_return)

    # Remove the first row because the first daily return is invalid
    df.drop(index=df.index[0], axis=0, inplace=True)

    # Store data for each stock
    stock["return"] = df["DailyReturn"].tolist()
    stock["risk"] = df["DailyRisk"].tolist()
    stock["avg_return"] = avg_return

    # Get only the last closing price (Last Price) as a float
    stock["last_price"] = df["Close"].iloc[-1].item()  # Retrieve only the scalar value

    stocks[symbol] = stock

# Create a table for display
table_data = []

for symbol, stock_data in stocks.items():
    table_data.append([
        symbol,
        stock_data['avg_return'],
        stock_data['last_price'],  # The last closing price (float)
        stock_data['return'][:1],  # The first daily return
        stock_data['risk'][:1]  # The first daily risk
    ])

# Create a DataFrame from the data above
df = pd.DataFrame(table_data, columns=["Stock Symbol", "Average Daily Return", "Last Price", "Daily Returns", "Daily Risks"])

df

# Function to convert all Series objects to lists
def convert_to_serializable(obj):
    if isinstance(obj, pd.Series):
        return obj.tolist()  # Convert Pandas Series to list
    elif isinstance(obj, dict):  # If the object is a dictionary, apply conversion recursively
        return {k: convert_to_serializable(v) for k, v in obj.items()}
    return obj  # Return the object as is if it's already serializable

# Convert the entire 'stocks' dictionary
stocks_serializable = convert_to_serializable(stocks)

# Now, write the dictionary to the JSON file
with open('portfolio.json', 'w') as fp:
    json.dump(stocks_serializable, fp, indent=4)

with open('portfolio.json', 'r') as fp:
    portfolio = json.load(fp)

"""# Stock Portfolio Optimization Model"""

solver = cplex.Cplex()

# daily return as a target
R_min = 0.00001  # Minimum daily return
R_max = 0.0005   # Maximum daily return

# total investment
I = 100000000

# total number of days in the analyzed data-set
T = len(list(portfolio.values())[0]['return'])

#total number of stocks in the portfolio
N = len(portfolio.keys())

"""## Adding variables to the model"""

# Initialize the CPLEX problem instance
problem = cplex.Cplex()
problem.set_problem_type(cplex.Cplex.problem_type.MILP)

# x = {stock_name: share} - proportion of each stock in the portfolio
# z = number of shares to purchase
x = {}
z = {}

# Define variables for stock proportions and number of shares
for stock in portfolio:
    # Add proportion variable (continuous between 0 and 1)
    x[stock] = len(problem.variables.get_names())
    problem.variables.add(
        obj=[0],
        lb=[0.05],   # Lower bound
        ub=[0.7],   # Upper bound
        names=[f'stock_proportion_{stock}']
    )

    # Add integer variable for the number of shares
    z[stock] = len(problem.variables.get_names())
    problem.variables.add(
        obj=[0],
        lb=[0],
        ub=[cplex.infinity],
        types=['I'],  # Integer variable
        names=[f'number_of_shares_{stock}']
    )

# y = {day_number: y} - average daily risk weighted by stock share
y = {}
for t in range(T):
    # Add risk variable (continuous, non-negative)
    y[t] = len(problem.variables.get_names())
    problem.variables.add(
        obj=[0],
        lb=[0],
        ub=[cplex.infinity],
        names=[f'avg_risk_{t}']
    )

print('Number of variables =', len(problem.variables.get_names()))

"""## Adding constraints to the model"""

for t in range(T):
    variables = [x[stock] for stock in x]
    coefficients = [portfolio[stock]["risk"][t] / N for stock in x]

    # Constrain 1: sum(x[stock]*portfolio[stock]["risk"][t] / N) >= -y[t]
    problem.linear_constraints.add(
        lin_expr=[[variables + [y[t]], coefficients + [-1]]],
        senses=["G"],
        rhs=[-1],
        names=[f"constraint_risk_lower_{t}"]
    )

    # Constrain 2: sum(x[stock]*portfolio[stock]["risk"][t] / N) <= y[t]
    problem.linear_constraints.add(
        lin_expr=[[variables + [y[t]], coefficients + [1]]],
        senses=["L"],
        rhs=[1],
        names=[f"constraint_risk_upper_{t}"]
    )

# Lower bound constraint: average return >= R_min
problem.linear_constraints.add(
    lin_expr=[[[x[stock] for stock in portfolio],  # Variables
               [portfolio[stock]["avg_return"] / N for stock in portfolio]]],  # Coefficients
    senses=["G"],
    rhs=[R_min],
    names=["constraint_return_min"]
)

# Upper bound constraint: average return <= R_max
problem.linear_constraints.add(
    lin_expr=[[[x[stock] for stock in portfolio],  # Variables
               [portfolio[stock]["avg_return"] / N for stock in portfolio]]],  # Coefficients
    senses=["L"],
    rhs=[R_max],
    names=["constraint_return_max"]
)

# Constraint 5: sum(x[stock] for stock in portfolio) == 1
problem.linear_constraints.add(
    lin_expr=[[[x[stock] for stock in portfolio],  # Variables
               [1.0] * len(portfolio)]],  # Coefficients, all are 1.0
    senses=["E"],
    rhs=[1.0],
    names=["constraint_sum_x"]
)

for stock in z:
    last_price = portfolio[stock]["last_price"]
    if isinstance(last_price, list):
        last_price = last_price[0]

    # Constraint 6: (x[stock] * I / last_price) == z[stock]
    problem.linear_constraints.add(
        lin_expr=[[[x[stock], z[stock]],
                   [I / last_price, -1.0]]],
        senses=["E"],
        rhs=[0.0],
        names=[f"constraint_stock_{stock}"]
    )

"""## Defining optimization function"""

# Define the objective function: Minimize the average of y[t] for all t
objective_coefficients = [1.0 / len(y) for t in y]  # Coefficients for the objective function
objective_variables = [y[t] for t in y]  # Variables to be minimized

# Set the objective function to minimize
problem.objective.set_linear(list(zip(objective_variables, objective_coefficients)))
problem.objective.set_sense(problem.objective.sense.minimize)

"""## Solution"""

problem.solve()

status = problem.solution.get_status()

if status == 101:
    print('Solution:')
    print('Objective value =', problem.solution.get_objective_value())

    total_investment = 0
    for stock in portfolio:
        x_value = problem.solution.get_values(f'stock_proportion_{stock}')
        print(f'x_{stock} = {x_value}')

        z_value = problem.solution.get_values(f'number_of_shares_{stock}')
        print(f'z_{stock} = {z_value}')

        last_price = portfolio[stock]["last_price"]
        if isinstance(last_price, list):
            last_price = last_price[0]

        print(f"Stock purchase = {z_value * last_price}")
        total_investment += z_value * last_price

    print("Total investment =", total_investment)

# Stock data
stocks = ["VIC.VN", "HPG.VN", "FPT.VN", "VCB.VN", "SSI.VN"]
proportions = [0.153039, 0.0762685, 0.051338, 0.050328, 0.6690265]
investments = [15303900.0, 7626850.0, 5133800.0, 5032800.0, 66902650.0]

# Colors for the plots
colors = ["#b9d6f3", "#f8dae9", "#c7ceea", "#e2f0cb", "#ff9aa2"]

# Create subplots
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Pie chart for proportions
axes[0].pie(
    proportions,
    labels=stocks,
    autopct="%1.1f%%",
    startangle=90,
    colors=colors,
    wedgeprops={"edgecolor": "black"},
)
axes[0].set_title("Stock Allocation by Proportion", fontsize=14)

# Bar chart for investments
axes[1].bar(stocks, investments, color=colors, edgecolor="black")
axes[1].set_title("Stock Allocation by Investment", fontsize=14)
axes[1].set_ylabel("Investment Amount (VND)", fontsize=12)
axes[1].set_xlabel("Stocks", fontsize=12)
axes[1].tick_params(axis="x", rotation=45)

# Adjust layout
plt.tight_layout()
plt.show()

